b'<HTML>\n<HEAD>\n<TITLE>Knowbot programming: System support for mobile agents</TITLE>\n</HEAD>\n<BODY>\n<CENTER>\n<H1>Knowbot programming: System support for mobile agents</H1>\n\n<BLOCKQUOTE>Jeremy Hylton, Ken Manheimer, Fred L. Drake Jr.,\n<BR>Barry Warsaw, Roger Masse, Guido van Rossum\n</BLOCKQUOTE>\n\n<P>Corporation for National Research Initiatives\n<BR>1895 Preston White Dr., Reston, VA 22091\n<BR>knowboteers@cnri.reston.va.us\n</CENTER>\n<H2>Abstract</H2>\n\n<P>Knowbot Programs are mobile agents intended for use in widely\ndistributed systems like the Internet. We describe our experiences\nimplementing security, process migration, and inter-process\ncommunication in a prototype system implemented using the\nobject-oriented programming language Python. This infrastructure\nsupports applications that are composed of multiple, autonomous\nagents that can migrate to use network resources more efficiently.\n\n<H2>1. Introduction</H2>\n\n<P>A Knowbot &reg; Program is a combination of data and a thread of control\nthat can move among nodes in a distributed system. The Knowbot\nOperating System provides a runtime environment for these programs\nwhich includes security mechanisms, support for migration, and\nfacilities for communication between Knowbot Programs.\n\n<P>Knowbot Programs enable an agent-based programming style that is\nwell-suited for autonomous and network-efficient applications. Agents\nare autonomous, able to continue operation even when disconnected from\ntheir source, and can migrate closer to data or to other programs they\ninteract with in order to conserve network bandwidth.\n\n<P>Our work is based on the Knowbot framework, introduced by Kahn and\nCerf [14], for a mobile software component to the national information\ninfrastructure.  Our experimental system explores some aspects of the\nKahn-Cerf framework.\n\n<P>This paper reviews our experience building a prototype system for\nsupporting Knowbot Programs and reviews some of the underlying\nservices provided by our Knowbot Operating System. It assumes a\ndistributed object framework for communicating with other parts of the\nsystem.\n\n<P>Our current implementation uses Python, an object oriented scripting\nlanguage [21], and ILU, a multilanguage object interface system\ndeveloped at Xerox PARC [10]. We use ILU to provide an object-\noriented RPC mechanism for communication between objects. The KOS\narchitecture, however, is language- and transport- neutral.\n\n<H2>2. Overview of system services</H2>\n\n<P>A Knowbot Program (KP) is code with well-defined entry point and\nstate. The Knowbot Operating System (KOS) is a runtime environment\nthat provides underlying services enabling KPs to migrate and to\ninteract with other programs. The underlying services fall into three\nmajor categories: (1) a safe runtime environment, (2) migration and\nstate management, and (3) communication among KPs. Each of these\nunderlying services is described in greater detail below; they are\nbriefly summarized here:\n\n<UL>\n\n<LI> Security. The prototype system provides several safeguards to\nprevent the KOS from being damaged by a KP. The KP process is\ndivided between a supervisor, which runs trusted code provided by\nthe KOS, and the KP user code, which is untrusted. The user code runs\nin a restricted execution environment, which mediates access to unsafe\noperations. The supervisor performs all restricted operations, like\nRPC calls, on behalf of the user code.\n\n<LI> Migration. A KP can move between distributed KOSes using two\nprimitives, migrate, which moves the current program, and clone, which\ncreates a copy of the current program at a new location. To migrate,\nthe KOS creates a package including the KP\'s source code, the\ncurrent state of the program, and a ``suitcase\'\' containing\napplication-specific data.\n\n<LI> Connectors. Connectors are a thin veneer over an object-oriented\nRPC mechanism that regulates the creation and publication of new\nobjects. All connectors are named and strongly typed. A KP can lookup\na particular connector by name or request a group of connectors that\nprovide the same interface.\n\n</UL>\n\n<P>Our use of connectors and ILU offers language independence for the\nKnowbot runtime environment. Any language that can support migration,\nhas an ILU binding, and a safe way to restrict access to unsafe\noperations can be used to write Knowbot Programs.  The rest of the\npaper describes our experience implementing Knowbot Programs and the\nunderlying services.\n\n<H2>3. Security</H2>\n\n<P>There are several levels of security needed in a mobile agent\nsystem; they include providing secure transport for KPs between\nKOSes, protecting the KP from tampering by the KOS, and protecting the\nKOS from malicious KPs. Our current implementation addresses only the\nlast issue -- executing the KP in safe environment.\n\n<P>Security in the KOS is based on the strict separation of\nresponsibilities between trusted and untrusted parts of the\nsystem. Untrusted user code runs in a restricted environment that is\ncreated for it by trusted supervisor code.\n\n<P>The restricted environment is indistinguishable to the untrusted code\nrunning within it, with the exception that various potentially\nunsafe operations are inaccessible. There are many potential unsafe\noperations -- creating network connections, modifying files on the\nlocal disk, or communicating with other KPs executing at the same\nnode. The trusted code removes some operations altogether and\ncreates wrappers around other operations that enforce security\npolicies.  For example, the supervisor may provide an open operation\nthat allows read and write operations only in particular\ndirectories. The open operation exported to user code would call into\nthe supervisor, where safety checks could be made before making the\nactual system call.\n\n<P>The KOS security model also guarantees type-safe access to distributed\nobjects by disabling access to an object\'s instance variables and by\nperforming runtime type-checking on all method calls. The trusted code\ncreates a ``bastion\'\' object that only allows calls to specific\ninstance methods. (The Thor object-oriented database [16] provides\nsimilar type-safe interaction using static type checking and\nencapsulation.)  A widely deployed mobile agent system will require\nstronger security measures than our prototype. For example, The KOS\nshould be able to identify the owner of the KP and verify its\nintegrity, based on a digital signature or encryption. Agent Tcl [8]\nuses PGP encryption for authentication and protection. When an agent\nis created it is signed or encrypted by its owner and submitted to a\nserver; when an agent moves between two servers, the originating\nserver encrypts the agent. The Agent Tcl system assumes that each\nserver trusts the others (and their public keys).\n\n<h2>4. Migration</H2>\n\n<P>Knowbot Programs control their location using two related operations,\nmigrate and clone. A KP calls migrate with the name of the destination\nKOS; the supervisor interrupts the KP, captures its current state in\npersistent form, and sends it to the specified KOS where execution\nresumes. The clone operation is the same as migrate, except that the\nclone call returns and execution continues at the original KOS.\nKnowbot Programs are transported between KOS nodes as MIME\ndocuments. The MIME representation includes the program\'s source code,\na pickled version of its running state, its ``suitcase\'\' (which holds\ndata files created by the KP), and metadata that describes how it\nshould be handled by the KOS. The metadata includes the KP\'s origin,\nthe name of the module that contains the KP entry point, and\ninstructions for handling exceptions and errors.\n\n<P>To support migration, the KOS must be able to stop a running KP,\nserialize its state, and restart the KP at another node based on that\nstate. In our current Python implementation, a KP always resumes\nexecution at a single entry point -- its main method. In the future,\nwe intend to support true stack mobility, which would allow a\nmigrating KP to resume execution at any point in the program,\npreserving its current call stack.\n\n<P>The KP\'s state includes all data stored within the KP object instance\nand references to other objects existing within the restricted KP\nenvironment, including connectors. Objects in the supervisor are not\nconsidered part of this state.\n\n<P>In Python, the KP\'s state is captured using an extended version of\nthe pickle library, which generates a machine-independent\nrepresentation of complex objects. Starting with a root object, that\nobject and any object it holds a reference to are added to the pickle.\nThe KP pickler supports custom pickling operations for objects. In the\ncase of connectors, a reference to the server\'s object and the type of\nthe object are placed in the pickle, and the unpickling method\nre-establishes the connection with the server. (The current imple-\nmentation does not address the reverse problem -- moving the KP\nwithout invalidating connectors to services it provides. Shapiro et\nal. [18], however, describe a solution using a chain of references\nthat point from the node where an object resided to the node it\nmigrated to.)\n\n<P>KPs also have access to a transported file system, or suitcase, to\ncarry data independently of the pickled program state. The suitcase\nholds application-created data that isn\'t stored as an instance\nvariable of the KP object, e.g. a log of KOSes visited or the results\nof a remote search. For convenience, the suitcase acts like a\nhierarchical file system. The suitcase offers two significant\nadvantages to applications:\n\n<UL>\n\n<LI> Files in the suitcase can be accessed without running the\nKP. Thus, an application that uses a KP to perform a remote operation\ncan retrieve the results without incurring the overhead of starting\na Python interpreter and the KP.\n\n<LI> The suitcase gives better performance to applications that\ncreate custom data representations.  For example, a KP that indexes\nWeb pages might write its index in binary form directly to the suit-\ncase and later transfer the index directly to a search service.\n\n</UL>\n\n<P>The Tacoma system [11] provides a similar facility for creating and\ncarrying files -- a ``briefcase\'\' that holds one or more ``folders.\'\'\nTacoma also allows an agent to store folders at the server, so that it\ncan store sitespecific data for later use.\n\n<H2>5. Connectors</H2>\n\n<P>Independently-running processes, including KPs and the KOS kernel,\ncommunicate with each other using connectors. Connectors are layered\non top of ILU objects, adding mechanisms for creating objects and\nsharing references to them.\n\n<P>Connectors preserve the integrity of the restricted execution\nenvironment, which could be compromised by offering lower-level access\nto object RPC mechanisms. A client KP uses connectors to request a\nservice, specifying a name and a type, and the KP supervisor creates a\nclient-side surrogate object that communicates with the process\noffering the service.\n\n<P>Programs offering services publish their services using the\nconnection broker, which binds connectors to instances of class\nobjects. The services class instance is bound to a symbolic name and\nan interface type registered with the KOS.\n\n<P>Knowbot programs define their own class objects and interface types\nusing interface definition language, which supports a large subset of\nCORBA functionality.  KPs communicate with each other using connectors\nto these well-defined interfaces. For example, a KP that searched a\nremote database would migrate to the KOS managing the database and\nrequest a connector for the database\'s search interface.\n\n<P>Clients can request a connector for a known service by specifying the\nservice\'s name and type. There are several other basic properties of\nconnectors:\n\n<UL>\n\n<LI> Clients can also look for all connectors of a particular\ninterface type.\n\n<LI> Connectors are first-class; they can be be delivered by other\nobjects.\n\n<LI> Clients can carry connectors from one station with them as they\ntravel to others, and maintain contact with the services they\nrepresent.\n\n</UL>\n\n<P>This connector architecture enables creation of addon directory, or\n``trader,\'\' services that track connectors based on more specific\nproperties. A directory service could be implemented by a KP that\nexports a directory interface to clients.\n\n<H2>6. Applications of Knowbot technology</H2>\n\n<P>An example of a complete Knowbot Program written in Python is shown\nin Figure 1. The KP searches up to 20 random KOSes looking for\nservices that implement the Search.Boolean interface, storing a list\nof those services in its suitcase. The code in Figure 1 shows a class\ndefinition for the KP that has four instance methods. The main\nmethod, invoked when the KP arrives at a new KOS, receives a bastion\nKOS object as its second argument; this object provides access to\nKOS services like connector lookup and migration.\n\n<P>More interesting applications of Knowbot technology include\napplications that make more efficient network bandwidth by moving\ncomputation closer to data or that implement widely distributed\nsystems on top of loosely coupled, autonomous Knowbot Programs.  One\nexample of the network-bandwidth-conserving Knowbot Program is one\nthat performs a search in an image database. Instead of loading each\nimage over the network and applying some computation to it, the KP\nmoves to the database, performs the search there, and returns with the\nresults.\n\n<PRE>\nimport rand                       # Python random number module\nimport nstools                    # helper module for using KOS namespace\n\nclass KP:\n\n    def __init__(self):\n        "Initialize KP\'s instance variables."\n        self.maxhops = 20\n        self.hopcount = 0\n        self.visited = []         # list of KOSes that have been visited\n\n    def __main__(self, kos):\n        "Finds services available here, then migrates to a new KOS."\n        self.find_services(kos, \'Search.Boolean\')\n        self.visited.append(kos.get_kos_name())\n        self.hopcount = self.hopcount + 1\n        if self.hopcount < self.maxhops:\n            places = self.get_new_places(kos)\n            if places:\n                kos.migrate(rand.choice(places))\n\n    def find_services(self, kos, service_type):\n        "Save a list of available services in the suitcase"\n        services = kos.list_services(service_type)\n        file = kos.get_suitcase().open(kos.get_kos_name(), \'w\')\n        for serv in services:\n            file.write(serv.name + \'\\n\')\n        file.close()\n\n    def get_new_places(self, kos):\n        "Return list of KOSes that have not been visited."\n        descriptor = nstools.Lookup(kos.get_namespace(), \'world/kos\')\n        context = descriptor.Open(\'Namespace.Context\')\n        places = []\n        for place in context.List():\n            if place not in self.visited: \n                places.append(place)\n        return places\n</PRE>\n<BLOCKQUOTE>\nFigure 1. Example Knowbot Program\n</BLOCKQUOTE>\n\n<P>The searching example can be extended to a more general indexing\nKnowbot Program, where a KP moves to a database to build an index of\nits contents. The KOS allows multiple search services to each build\ntheir own customized index of database without copying the database\'s\nentire contents [9].\n\n<P>Intellectual property rights management and control of caching and\nreplication are areas where the ability to create autonomous Knowbot\nPrograms is valuable.  A Knowbot Program can act as a courier for data\nfor which access is restricted. The KP carries an encrypted version of\nthe data and requires some authentication or payment to decrypt it,\nperhaps interacting with another KP that carries a key for decryption.\nWe can generalize this example to a general mechanism for providing\ncaching and replication of objects on the World-Wide Web. We envision\na proxy server that runs Knowbot Programs. A content provider\ninteracts with a proxy server by sending a group of objects managed by\na KP. The manager program could enforce access controls, perform\nspecialized logging (hit counts), or generate dynamic pages using a\ndatabase copied from the content provider. The manager also helps deal\nwith the cache consistency program, because the manager can contain\nsite-specific code for make decisions about freshness.\n\n<H2>7. Related Work</H2>\n\n<P>An increasing number of agent-based programming systems are being\ndescribed in the research literature.  Support for mobility in these\nsystems builds on earlier work on object migration.\n\n<P>Emerald [13] was one of the first systems to support fine-grained\nmobility for objects and processes, i.e. a thread executes within an\nobject and moves with that object. The Emerald system was designed for\na small-scale network of homogeneous computers, although a recent\npaper discusses mobility among heterogeneous computers [19].\n\n<P>Object migration is also of interest in mobile computing, where there\nis great need to reduce bandwidth requirements and cope with\nintermittent lack of connectivity. The Rover toolkit [12] uses\nrelocatable dynamic objects to move computation between servers and\nmobile clients. However, these objects do not maintain an active\nthread of control as they move.  Recent work on agent technology\nincludes several systems using high-level scripting languages like Tcl\nand the commercial Telescript system from General Magic.\n\n<P>Agent Tcl [8, 15] extends the standard Safe Tcl interpreter with\nfacilities for migration and resource allocation. The system provides\nfor encrypted and authenticated transport of agents and for limited\ncontrol over the resources an agent can use (e.g. CPU time, disk\nspace).\n\n<P>Another agent environment using Tcl is Tacoma\n[11], which also supports agents written in Perl,\nPython, and Scheme. In Tacoma, agents communicate\nusing shared files, or ``folders:\'\' One agent places some\ndata in a folder and issues a meet instruction specifying another agent. That agent begins execution with\nthe suitcase from the first agent. All system services\nare structured as agents run by meet.\n\n<P>Obliq [5] is a scripting language for distributed object-oriented\ncomputing that is based on a network object [4] model. Bharat and\nCardelli [3] describe several interactive applications that migrate\nthe user interface to the user\' site.\n\n<P>General Magic has developed a commercial agent system centered around\nits programming language Telescript [22]. Telescript addresses\nmigration, security, and resource control. The system, however,\nexposes a complex security model to the programmer [20] and does not\nsupport programs written in more common scripting languages.\n\n<P>Research in safe programming languages is an important enabling\ntechnology for agent systems. The Safe-Tcl and Java languages also\noffer restricted environments. Sandboxing [2] is an alternative to\nPython\'s restricted execution environment.\n\n<P>Java has also been proposed as a language for agent programming, but\nthe language itself does not provide necessary support services for\nagents. Using Java applets involve many of the same security concerns\nas agents [7]. Several projects have proposed to use or are using Java\nfor agent system: Sumatra [1, 17] is an extension to Java that\nsupports mobile programs that adapt to changing network\nconditions. The Open Software Foundation has proposed a middleware\nsystem written in Java [6].\n\n<H2>8. Conclusions and future work</H2>\n\n<P>We expect to refine and extend the current prototype of the Knowbot\nOperating System and make its source code available to other\nresearchers in the coming year.\n\n<P>There are several unexplored aspects of Knowbot programming that will\nbe addressed in our future work: (1) developing a broader security\nmodel for KPs that addresses access control, authentication and\nverification of KPs and KOSes, and resource management, (2)\nimplementing support for KPs written in multiple languages, (3) using\nmigration to experiment with scheduling and load balancing algorithms,\nand (4) instrumenting the system to study efficiency and\nperformance. We are also developing several real-world applications to\nconfirm our expectations about the usefulness of Knowbot programming.\n\n<H2>9. Acknowledgments</H2>\n\n<P>Amy Friedlander made many helpful comments on this paper. Our work was\nsupported by the Advanced Research Projects Agency of the United\nStates Department of Defense under grant MDA972-95-1-0003.\n\n<H2>References</H2>\n\n<OL>\n\n<LI> A. Acharya, M. Ranganathan, and J. Saltz. <A\nHREF="http://www.cs.umd.edu/~acha/papers/iwoos96-submitted.html">Distributed\nresource monitors for mobile objects.</A> In Proceedings of the Fifth\nIEEE International Workshop on Object-Orientation in Operating\nSystems, Oct. 1996.\n\n<LI> A.-R. Adl-Tabatabai, G. Langdale, S. Lucco, and\nR. Wahbe. Efficient and language-independent mobile programs. In\nProceedings of the ACM SIGPLAN \'96 Conference on Programming Language\nDesign and Implementation (PLDI), pages 127--136, May 1996.\n\n<LI> K. A. Bharat and L. Cardelli. <A\nHREF="http://gatekeeper.dec.com/pub/DEC/SRC/research-reports/abstracts/src-rr-138.html">Migratory\napplications.</A> In Proceedings of the 8th Annual ACM Symposium on\nUser Interface Software and Technology, Nov. 1995.\n\n<LI> A. Birrell, G. Nelson, S. Owicki, and E. Wobber.  <A\nHREF="http://gatekeeper.dec.com/pub/DEC/SRC/research-reports/abstracts/src-rr-115.html">Network\nobjects.</A> Software--Practice and Experience, 25(S4):87--130,\nDec. 1995. Also available as DEC SRC Research Report 115.\n\n<LI> L. Cardelli. <A\nHREF="http://gatekeeper.dec.com/pub/DEC/SRC/research-reports/abstracts/src-rr-122.html">A\nlanguage with distributed scope.</A> Computing Systems, 8(1):27--59,\n1995.\n\n<LI> M. Condict, D. Milojicic, F. Reynolds, and D. Bolinger. Towards a\nworld-wide civilization of objects. In 7th SIGOPS European Workshop,\nSept. 1996.\n\n<LI> D. Dean, E. Felten, and D. Wallach. <A\nHREF="http://www.cs.princeton.edu/sip/pub/secure96.html">Java\nsecurity: From HotJava to Netscape and beyond.</A> In Proceedings of\nthe 1996 IEEE Symposium on Security and Privacy, May 1996.\n\n<LI> R. S. Gray. <A HREF="http://www.cs.dartmouth.edu/~agent/papers/tcl96.ps.Z">Agent Tcl: A flexible and secure mobile agent\nsystem.</A> In Proceedings of the Fourth Annual Tcl/Tk Workshop, pages\n9--23, July 1996.\n\n<LI> J. Hylton. <A\nHREF="http://www.CNRI.Reston.Va.US/home/dobi/collections.html">Creating\ncollections with a distributed indexing infrastructure.</A> May\n1996. Position statement for the W3C Distributed Indexing/Searching\nWorkshop.\n\n<LI> B. Janssen, D. Severson, and M. Spreitzer. <A\nHREF="ftp://ftp.parc.xerox.com/pub/ilu/ilu.html">ILU 1.8 Reference\nManual.</A> Xerox Corp., 1995. Available via Inter-Language\nUnification Web page.\n\n<LI> D. Johansen, R. van Renesse, and F. B. Schneider.  <A\nHREF="http://cs-tr.cs.cornell.edu/TR/CORNELLCS:TR94-1468">Operating\nsystem support for mobile agents.</A> In Proceedings of the 5th IEEE\nWorkshop on Hot Topics on Operating Systems, pages 42--45, May 1994.\n\n<LI> A. D. Joseph, A. F. deLespinasse, J. A. Tauber, D. K.  Gifford,\nand M. F. Kaashoek. <A\nHREF="http://www.pdos.lcs.mit.edu/papers/rover-sosp95.ps">Rover: A\ntoolkit for mobile information access.</A> In Proceedings of the 15th\nACM Symposium on Operating Systems Principles, pages 156--171,\nDec. 1995.\n\n<LI> E. Jul, H. Levy, N. Hutchinson, and A. Black. Fine-grained\nmobility in the Emerald system. ACM Transactions on Computer\nSystems, 6(2):109--133, Feb.  1988.\n\n<LI> R. E. Kahn and V. G. Cerf. The Digital Library Project, volume I:\nThe world of Knowbots. Unpublished manuscript, Corporation for\nNational Research Initiatives, Reston, Va., Mar. 1988.\n\n<LI> D. Kotz, R. Gray, and D. Rus. <A HREF="http://www.cs.dartmouth.edu/~dfk/papers/kotz:agents.html">Transportable agents support\nworldwide applications.</A> In 7th SIGOPS European Workshop, Sept. 1996.\n\n<LI> B. Liskov, A. Adya, M. Castro, M. Day, S. Ghemawat, R. Gruber,\nU. Maheshwari, A. C. Myers, and L. Shrira. <A\nHREF="ftp://ftp.pmg.lcs.mit.edu/pub/thor/thor.ps">Safe and efficient\nshareing of persistent objects in Thor.</A> In Proceedings of the 1996\nACM SIGMOD International Conference on Management of Data, pages\n318--329, June 1996.\n\n<LI> M. Ranganathan, A. Acharya, S. Sharma, and J. Saltz.  <A\nHREF="http://www.cs.umd.edu/~acha/papers/usenix97-submitted.html">Network-aware\nmobile programs.</A> Submitted for publication, 1996.\n\n<LI> M. Shapiro, P. Dickman, and D. Plainfoss\'e. <A\nHREF="http://www.inesc.research.ec.org/broadcast/trs/">Robust,\ndistributed references and acyclic garbage collection.</A> In\nSymposium on Principles of Distributed Computing, pages 135--146,\nAug. 1992. Revised version available as Rapport de Recherche INRIA\n1799 and Broadcast Technical Report no. 1.\n\n<LI> B. Steensgaard and E. Jul. <A\nHREF="ftp://ftp.research.microsoft.com/users/rusa/sosp95.ps">Object\nand native code thread mobility among heterogeneous computers.</A> In\nProceedings of the 15th ACM Symposium on Principles of Operating\nSystems, pages 68--78, Dec. 1995.\n\n<LI> J. Tardo and L. Valenta. <A\nHREF="http://www.genmagic.com/Telescript/Compcon96.ps">Mobile agent\nsecurity and Telescript.</A> In Proceedings of IEEE COMPCON \'96,\nFeb. 1996.\n\n<LI> G. van Rossum. <A HREF="http://www.python.org/doc/tut/tut.html">Python tutorial.</A> Technical Report CS-R9526,\nCentrum voor Wiskunde en Informatica (CWI), Amsterdam, May 1995.\n\n<LI> J. E. White. <A HREF="http://www.genmagic.com/Telescript/Whitepapers/wp1/whitepaper-1.html">Telescript technology: The foundation for the\nelectronic marketplace.</A> Available at Web page titled "Telescript\nTechnology: Whitepaper #1," 1996.\n\n</OL>\n\n<HR>\n\n<P>Citation: Jeremy Hylton, Ken Manheimer, Fred L. Drake Jr.,\nBarry Warsaw, Roger Masse, and Guido van Rossum. Knowbot Programming:\n      System Support for Mobile Agents. In Proceedings of the 5th\n\tInternational Workshop on Object Orientation in Operating\n\tSystems (IWOOOS \'96), pages 8-13, Oct. 1996.\n\n\n<P>Copyright &copy; 1996 Corporation for National Research\nInitiatives, Institute of Electrical and Electronics Engineers.\n'